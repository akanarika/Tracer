<!DOCTYPE html>
<html>
	<head>
		<title>Tracer</title>
		<link rel="stylesheet" href="style.css" type="text/css">

	</head>
	<body>
        <div style="text-align:center">
            <canvas id="c" width="800" height="600" style="border:1px solid #000;"></canvas>
        </div>
        <script id="vs" type="notjs">
            attribute vec2 a_pixel;    
            uniform mat4 u_matrix;
            varying vec3 pixel;

            void main() {
                pixel = vec3(a_pixel + vec2(0.5, 0.5), -500.0);
                gl_Position = u_matrix * vec4(a_pixel, 0.0, 1.0);
                gl_PointSize = 1.0;
            }
        </script>
		<script id="fs" type="notjs">
            precision mediump float;

            struct Mat {
                int i; // diffuse - 1, metal - 2
                vec3 att; // attenuation
            };

            struct Sphere {
                vec3 o;
                float r;
                Mat mat;
            };

            struct Plane {
                vec3 n;
                vec3 p;
                Mat mat;
            };

            struct Triangle {
                vec3 p0;
                vec3 p1;
                vec3 p2;
                Mat mat;
            };

            struct Light {
                vec3 p;
            };

            struct Cam {
                vec3 o;
                vec3 gaze;
                vec3 up;
                float focal;
            };

            struct Ray {
                vec3 o;
                vec3 d;
                float t_min;
                float t_max;
            };

            struct Hit {
                float t;
                vec3 p;
                vec3 n;
                Mat mat;
            };

            uniform float w;
            uniform float h;
            uniform float u_seed;
            uniform Sphere u_spheres[10];
            uniform vec3 u_cursor;
            uniform int u_sample_count;
            uniform bool u_ground;

            varying vec3 pixel;
            vec4 bg_color = vec4(0.4, 0.4, 0.0, 1.0);
            const float pi = 3.141592653589;
            const float maxf = 100000000000.0;
            float n_seed = u_seed;

            Sphere spheres[10];
            Plane ground;
            Triangle tri;
            Cam cam = Cam(vec3(0., 0., 6000.), vec3(0, 0, -1.0), vec3(0, 1.0, 0), 10.);

            Light light;

            // Unitilities 
            // 0 ~ 1.0
            float random(inout float seed) {
                vec3 scale = vec3(12.9898, 78.233, 151.7182);
                seed += 1.1;
                if (seed > 10000000.0) seed = 0.0;
                return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
            }

            vec3 random_unit_vector() {
                float a = random(n_seed) * 2.0 * pi;
                float z = random(n_seed) * 2.0 - 1.0;
                float r = sqrt(1.0 - z * z);
                return vec3(r * cos(a), r * sin(a), z);
            }

            mat2 transpose(mat2 m) {
              return mat2(m[0][0], m[1][0],
                          m[0][1], m[1][1]);
            }

            mat3 transpose(mat3 m) {
              return mat3(m[0][0], m[1][0], m[2][0],
                          m[0][1], m[1][1], m[2][1],
                          m[0][2], m[1][2], m[2][2]);
            }

            mat4 transpose(mat4 m) {
              return mat4(m[0][0], m[1][0], m[2][0], m[3][0],
                          m[0][1], m[1][1], m[2][1], m[3][1],
                          m[0][2], m[1][2], m[2][2], m[3][2],
                          m[0][3], m[1][3], m[2][3], m[3][3]);
            }

            float inverse(float m) {
              return 1.0 / m;
            }

            mat2 inverse(mat2 m) {
              return mat2(m[1][1],-m[0][1],
                         -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
            }

            mat3 inverse(mat3 m) {
              float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
              float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
              float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

              float b01 = a22 * a11 - a12 * a21;
              float b11 = -a22 * a10 + a12 * a20;
              float b21 = a21 * a10 - a11 * a20;

              float det = a00 * b01 + a01 * b11 + a02 * b21;

              return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
                          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
                          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
            }

            mat4 inverse(mat4 m) {
              float
                  a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
                  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
                  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
                  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

                  b00 = a00 * a11 - a01 * a10,
                  b01 = a00 * a12 - a02 * a10,
                  b02 = a00 * a13 - a03 * a10,
                  b03 = a01 * a12 - a02 * a11,
                  b04 = a01 * a13 - a03 * a11,
                  b05 = a02 * a13 - a03 * a12,
                  b06 = a20 * a31 - a21 * a30,
                  b07 = a20 * a32 - a22 * a30,
                  b08 = a20 * a33 - a23 * a30,
                  b09 = a21 * a32 - a22 * a31,
                  b10 = a21 * a33 - a23 * a31,
                  b11 = a22 * a33 - a23 * a32,

                  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

              return mat4(
                  a11 * b11 - a12 * b10 + a13 * b09,
                  a02 * b10 - a01 * b11 - a03 * b09,
                  a31 * b05 - a32 * b04 + a33 * b03,
                  a22 * b04 - a21 * b05 - a23 * b03,
                  a12 * b08 - a10 * b11 - a13 * b07,
                  a00 * b11 - a02 * b08 + a03 * b07,
                  a32 * b02 - a30 * b05 - a33 * b01,
                  a20 * b05 - a22 * b02 + a23 * b01,
                  a10 * b10 - a11 * b08 + a13 * b06,
                  a01 * b08 - a00 * b10 - a03 * b06,
                  a30 * b04 - a31 * b02 + a33 * b00,
                  a21 * b02 - a20 * b04 - a23 * b00,
                  a11 * b07 - a10 * b09 - a12 * b06,
                  a00 * b09 - a01 * b07 + a02 * b06,
                  a31 * b01 - a30 * b03 - a32 * b00,
                  a20 * b03 - a21 * b01 + a22 * b00) / det;
            }

            float determinant(float m) {
                return m;
            }

            float determinant(mat2 m) {
                return m[0][0] * m[1][1] - m[0][1] * m[1][0]; 
            }

            float determinant(mat3 m) {
                return m[0][0] * (m[2][2]*m[1][1] - m[1][2]*m[2][1])
                + m[0][1] * (m[1][2]*m[2][0] - m[2][2]*m[1][0])
                + m[0][2] * (m[2][1]*m[1][0] - m[1][1]*m[2][0]);
            }

            float determinant(mat4 m) {
                float
                    b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0],
                    b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0],
                    b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0],
                    b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1],
                    b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1],
                    b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2],
                    b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0],
                    b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0],
                    b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0],
                    b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1],
                    b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1],
                    b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            }

            bool intersectSphere(in Ray ray, Sphere sphere, out Hit hit) {
                float a = dot(ray.d, ray.d);
                float half_b = dot(ray.d, ray.o - sphere.o);
                float c = dot(ray.o - sphere.o, ray.o - sphere.o) - sphere.r * sphere.r;
                float qua_delta	= half_b * half_b - a * c;
                if (qua_delta < 0.0) return false;
                float t = (- half_b - sqrt(qua_delta)) / a; // smaller root
                if ((t > ray.t_min) && (t < ray.t_max)) {
                    hit.t = t;
                    hit.p = ray.o + ray.d * t;
                    hit.n = normalize(hit.p - sphere.o);
                    hit.mat = sphere.mat;
                    return true;
                }
                return false;
            }

            bool intersectPlane(inout Ray ray, Plane plane, out Hit hit) {
                if (!u_ground) return false;
                float t = (dot(plane.n, plane.p) - dot(plane.n, ray.o)) / dot(plane.n, ray.d);
                if (t > ray.t_min && t < ray.t_max) {
                    hit.t = t;
                    hit.p = ray.o + ray.d * t;
                    hit.n = plane.n;
                    hit.mat = plane.mat;
                    return dot(hit.n, ray.d) > 0. ? false : true;
                }
                return false;
            }

            bool intersectTriangle(Ray ray, Triangle tri, out Hit hit) {
                mat3 A = mat3(tri.p0 - tri.p1, tri.p0 - tri.p2, ray.d);
                float detA = determinant(A);
                float beta = determinant(mat3(tri.p0 - ray.o, tri.p0 - tri.p2, ray.d)) / detA;
                float gamma = determinant(mat3(tri.p0 - tri.p1, tri.p0 - ray.o, ray.d)) / detA;
                float t = determinant(mat3(tri.p0 - tri.p1, tri.p0 - tri.p2, tri.p0 - ray.o)) / detA;
                if (t > ray.t_max || t < ray.t_min) return false;
                if (gamma < 0. || gamma > 1.) return false;
                if (beta < 0. || beta > 1. - gamma) return false;
                vec3 n = cross(tri.p1 - tri.p0, tri.p2 - tri.p0);
                if (dot(ray.d, n) > 0.) return false;
                hit.t = t;
                hit.n = n;
                hit.p = ray.o + ray.d * t;
                hit.mat = tri.mat;
                return true;
            }

            bool intersect(in Ray ray, inout Hit hit) {
                bool did_hit = false;
                if (intersectPlane(ray, ground, hit)) {
                    ray.t_max = hit.t;
                    did_hit = true;
                }
                if (intersectTriangle(ray, tri, hit)) {
                    ray.t_max = hit.t;
                    did_hit = true;
                }
                for (int i = 0; i < 10; i++) {
                    if (intersectSphere(ray, spheres[i], hit)) {
                        ray.t_max = hit.t;
                        did_hit = true;
                    }
                }
                return did_hit;
            }

            vec3 randPointInSphere() {
                vec3 off = vec3(0.0, 0.0, 0.0);
                for (int i = 0; i < 100000; i++) {
                    off = vec3(random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0);
                    if (dot(off, off) > 1.0) continue;
                    return off;
                }
                return off;
            }

            bool shoot_ray(in Ray ray, inout vec4 color, out Hit hit) {
                if (!intersect(ray, hit)) return false;                
                color = vec4(0.5 * vec3(hit.n.x + 1.0, hit.n.y + 1.0, hit.n.z + 1.0), 1.0);
                return true;
            }

            bool shoot_rays(in Ray ray, inout vec4 color) {
                bool did_hit = false;
                for (int i = 0; i < 100; i++) {
                    if (i > u_sample_count) break;
                    Ray nr = Ray(ray.o, ray.d + vec3(random(n_seed) - 0.5, random(n_seed) - 0.5, 0), 0., maxf);
                    Hit hit;
                    vec4 single_color;
                    float fac = 1.0;
                    vec3 fac3 = vec3(1.0);
                    for (int d = 0; d < 50; d++) {
                        if (shoot_ray(nr, single_color, hit)) {
                            did_hit = true;
                            if (hit.mat.i == 1) {
                                fac = 0.5 * fac;
                                vec3 target = hit.p + hit.n + random_unit_vector();
                                nr.o = hit.p;
                                nr.d = target - hit.p;
                            } else {
                                fac3 = vec3(hit.mat.att.x * fac3.x, hit.mat.att.y * fac3.y, hit.mat.att.z * fac3.z);
                                vec3 reflect = nr.d - 2.0 * dot(nr.d, hit.n) * hit.n;
                                nr.o = hit.p;
                                nr.d = reflect;
                                if (dot(reflect, hit.n) < 0.0) continue;
                            }
                        } else {
                            if (!did_hit) {
                                color = color + fac * bg_color;
                            } else if (hit.mat.i == 1) {
                                color = color + fac * vec4(hit.mat.att, 1.0);
                            } else {
                                color = color + vec4(fac3.x * bg_color.x, fac3.y * bg_color.y, fac3.z * bg_color.z, 1.0);
                            }
                            break;
                        }
                    }
                }
                return did_hit;
            }

            vec4 out_color(in vec4 color, in int sample_count) {
                float sample_count_f = float(sample_count);
                float scale = 1.0 / sample_count_f;
                return vec4(sqrt(color.x * scale), sqrt(color.y * scale), sqrt(color.z * scale), 1.0);
            }

            void transformWorld(mat4 view) {
                for (int i = 0; i < 10; i++) {
                    spheres[i].o = vec3(view * vec4(spheres[i].o, 1.));
                }

                ground.n = vec3(view * vec4(ground.n, 0.));
                ground.p = vec3(view * vec4(ground.p, 1.));

                tri.p0 = vec3(view * vec4(tri.p0, 1.));
                tri.p1 = vec3(view * vec4(tri.p1, 1.));
                tri.p2 = vec3(view * vec4(tri.p2, 1.));

                light.p = vec3(view * vec4(light.p, 1.));
            }

            void main() {
                float yaw = u_cursor[0];
                float pitch = - u_cursor[1];
                mat4 r_yaw = mat4(cos(yaw), -sin(yaw), 0, 1.,
                                sin(yaw), cos(yaw), 0, 1.,
                                0, 0, 1., 0.,
                                0, 0, 0, 1.);
                mat4 r_pitch = mat4(1., 0, 0, 0,
                                    0, cos(pitch), -sin(pitch), 0,
                                    0, sin(pitch), cos(pitch), 0,
                                    0, 0, 0, 1.);
                mat4 rot = r_pitch*r_yaw;
                cam.gaze = vec3(rot * vec4(cam.gaze, 1.0));
                cam.o = vec3(rot * vec4(cam.o, 1.0));
                cam.up = vec3(rot * vec4(cam.up, 1.0));

                vec3 gu = normalize(cross(cam.gaze, cam.up));
                mat4 rotate = mat4(transpose(mat3(gu, cam.up, -cam.gaze)));
                mat4 tran = mat4(1., 0., 0., 0.,
                                0., 1., 0., 0.,
                                0., 0., 1., 0.,
                                -cam.o.x, -cam.o.y, -cam.o.z, 0.);
                mat4 view = rotate * tran;

                float bottom = 0.;
                for (int i = 0; i < 10; i++) {
                    spheres[i] = u_spheres[i];
                    bottom = min(bottom, spheres[i].o.y - spheres[i].r);
                }
                ground = Plane(normalize(vec3(0, 5., 1.)), vec3(0, bottom, 0), Mat(1, vec3(.2, .6, .6)));
                tri = Triangle(vec3(0., 0., 0.), vec3(5000., 0, 0.), vec3(2000., 2000., -1800.), Mat(1, vec3(.3)));
                light = Light(vec3(0., 10., 10.));

                transformWorld(view);

                Ray ray;
                ray.o = vec3(0);
                ray.d = pixel - ray.o;
                vec4 color = vec4(0);
                float t = 0.5 * (normalize(ray.d).y + 1.0);
                bg_color = (1.0 - t) * vec4(1.0) + t * bg_color;
                shoot_rays(ray, color);
                gl_FragColor = out_color(color, u_sample_count);
            }

		</script>
        <script src="vector.js"></script>
        <script src="matrix.js"></script>
        <script type="text/javascript" src="dat.gui.min.js"></script>
		<script src="main.js"></script>

	</body>
</html>
