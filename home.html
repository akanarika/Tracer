<!DOCTYPE html>
<html>
	<head>
		<title>Tracer</title>
		<link rel="stylesheet" href="style.css" type="text/css">

	</head>
	<body>
        <div style="text-align:center">
            <canvas id="c" width="800" height="600" style="border:1px solid #FFF;"></canvas>
        </div>
        <script id="vs" type="notjs">
        	attribute vec2 a_pixel;                                                                                                         
			uniform mat3 u_matrix;                                                                                                          
			varying vec3 pixel;                                                                                                             
			void main() {
				pixel = vec3(a_pixel, 0) + vec3(0.5, 0.5, 0);
			    gl_Position = vec4((u_matrix * vec3(a_pixel, 1.0)).xyz, 1.0);
			    gl_PointSize = 1.0;
			}
        </script>
		<script id="fs" type="notjs">
            precision mediump float;

            struct Sphere {
                vec3 o;
                float r;
            };

            struct Cam {
                vec3 o;
                float focal;
            };

            struct Ray {
                vec3 o;
                vec3 d;
            };

            struct Hit {
                float t;
                vec3 p;
                vec3 n;
            };
            
            uniform float w;
            uniform float h;
            uniform float u_seed;
            uniform Cam cam;
            uniform Sphere spheres[2];
            varying vec3 pixel;
            vec4 bg_color = vec4(0.8, 0.3, 0.6, 1.0);
            const int sample_count = 100;
            const float pi = 3.141592653589;
            float n_seed = u_seed;

            // 0 ~ 1.0
            float random(inout float seed) {
                vec3 scale = vec3(12.9898, 78.233, 151.7182);
                seed += 1.1;
                if (seed > 10000000.0) seed = 0.0;
                return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
            }

            vec3 random_unit_vector() {
                float a = random(n_seed) * 2.0 * pi;
                float z = random(n_seed) * 2.0 - 1.0;
                float r = sqrt(1.0 - z * z);
                return vec3(r * cos(a), r * sin(a), z);
            }

            bool intersectSphere(in Ray ray, Sphere sphere, float t_min, out float t) {
                float a = dot(ray.d, ray.d);
                float half_b = dot(ray.d, ray.o - sphere.o);
                float c = dot(ray.o - sphere.o, ray.o - sphere.o) - sphere.r * sphere.r;
                float qua_delta	= half_b * half_b - a * c;
                if (qua_delta < 0.0) return false;
                t = (- half_b - sqrt(qua_delta)) / a; // smaller root
                if (t > t_min) return true;
                t = (- half_b + sqrt(qua_delta)) / a; // larger root
                if (t > t_min) return true;
                return false;
            }

            bool intersect(in Ray ray, out Hit hit) {
                bool did_hit = false;
                for (int i = 0; i < 2; i++) {
                	float t;
                    if (intersectSphere(ray, spheres[i], 0.0, t)) {
                        if (!did_hit || t < hit.t) {
                            did_hit = true;
                            hit.t = t;
                            hit.p = ray.o + ray.d * t;
                    	    hit.n = normalize(hit.p - spheres[i].o);
                        }   
                    }
                }
                return did_hit;
            }

            vec3 randPointInSphere() {
                vec3 off = vec3(0.0, 0.0, 0.0);
                for (int i = 0; i < 100000; i++) {
                    off = vec3(random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0);
                    if (dot(off, off) > 1.0) continue;
                    return off;
                }
                return off;
            }

            bool shoot_ray(in Ray ray, inout vec4 color, out Hit hit) {
                if (!intersect(ray, hit)) return false;                
                color = vec4(0.5 * vec3(hit.n.x + 1.0, hit.n.y + 1.0, hit.n.z + 1.0), 1.0);
                return true;
            }

            bool shoot_rays(in Ray ray, inout vec4 color) {
                bool last_hit = false;
                bool did_hit = false;
                for (int i = 0; i < sample_count; i++) {
                    Ray nr;
                    nr.o = ray.o;
                    nr.d = ray.d + vec3(random(n_seed) - 0.5, random(n_seed) - 0.5, 0);
                    Hit hit;
                    vec4 single_color;
                    float fac = 1.0;
                    for (int d = 0; d < 30; d++) {
                        if (shoot_ray(nr, single_color, hit)) {
                            did_hit = true;
                            fac = 0.5 * fac;
                            vec3 target = hit.p + hit.n + random_unit_vector();
                            nr.o = hit.p;
                            nr.d = target - hit.p;
                        } else {
                            color = color + fac * bg_color;
                            break;
                        }
                    }
                }
                return did_hit;
            }

            vec4 out_color(in vec4 color, in int sample_count) {
                float sample_count_f = float(sample_count);
                float scale = 1.0 / sample_count_f;
                return vec4(sqrt(color.x * scale), sqrt(color.y * scale), sqrt(color.z * scale), 1.0);
            }

			void main() {
                Ray ray;
                ray.o = cam.o;
                ray.d = pixel - ray.o;
                vec4 color = vec4(0);
                float t = 0.5 * (normalize(ray.d).y + 1.0);
                bg_color = (1.0 - t) * vec4(1.0) + t * bg_color;
                shoot_rays(ray, color);
                gl_FragColor = out_color(color, sample_count);
			}

		</script>
		<script src="main.js"></script>
	</body>
</html>
